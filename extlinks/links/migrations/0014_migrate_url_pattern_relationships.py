# Generated by Django 4.2.14 on 2024-08-20 17:14
from django.contrib.contenttypes.models import ContentType
from django.core.paginator import Paginator
from django.core.serializers import deserialize
from django.db import migrations

import logging

logger = logging.getLogger(__name__)
handler = logging.StreamHandler()
logger.addHandler(handler)
logger.setLevel(logging.INFO)

def import_url_collection_json():
    with open("./extlinks/links/migrations/urlpatterns.json", "r") as f:
        logger.info("\timporting urlpatterns ...")
        url_pattern_data = deserialize("json", f)
        for url_pattern in url_pattern_data:
            url_pattern.save()


def process_link_event(link_event):
    #logger.info("\tprocessing linkevent: {}".format(link_event.id))
    urlpatterns = (
        link_event.url.all()
        .order_by("-url__length")
    )

    # Find opportunities for early exit
    if not urlpatterns:
        logger.info("\t\tlinkevent {}:\tno url patterns found!".format(link_event.id))
        return
    pattern_count = len(urlpatterns)
    if pattern_count == 1:
        link_event.object_id = urlpatterns[0].pk
        link_event.content_type_id = ContentType.objects.get(model="urlpattern").id
        link_event.content_object = urlpatterns[0]
        link_event.save()
        return
    elif pattern_count > 2:
        logger.info("\t\tlinkevent {}:\tmore than 2 url patterns found!".format(link_event.id))
        return

    # @FIXME: unreachable?
    # Save the longest (i.e. most specific) URL pattern in the link event
    # link_event.object_id = urlpatterns[0].pk
    # link_event.content_type_id = ContentType.objects.get(model="urlpattern").id
    # link_event.content_object = urlpatterns[0]
    # link_event.save()

def migrate_relationships(apps, schema):
    logger.info("\n")
    import_url_collection_json()
    LinkEvent = apps.get_model("links", "LinkEvent")
    paginator = Paginator(
        LinkEvent.objects.filter(content_type__isnull=True).order_by("id"), 1000
    )
    last_page = paginator.page_range[-1]
    for page_num in paginator.page_range:
        logger.info("\tprocessing linkevent page: {page_num}/{last_page}".format(page_num=page_num,last_page=last_page))
        for link_event in paginator.page(page_num).object_list:
            process_link_event(link_event)


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("links", "0013_add_linkevent_url_linkevent_content_type_and_more"),
    ]

    operations = [
        migrations.RunPython(migrate_relationships),
    ]
